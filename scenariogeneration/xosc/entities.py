"""
scenariogeneration
https://github.com/pyoscx/scenariogeneration

This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at https://mozilla.org/MPL/2.0/.

Copyright (c) 2022 The scenariogeneration Authors.

"""

import xml.etree.ElementTree as ET
from typing import Optional, Union
from collections import namedtuple

from .enumerations import (
    MiscObjectCategory,
    ObjectType,
    PedestrianCategory,
    Role,
    VehicleCategory,
    VersionBase,
)
from .exceptions import OpenSCENARIOVersionError, XMLStructureError
from .utils import (
    BoundingBox,
    CatalogReference,
    Controller,
    DynamicsConstraints,
    EntityRef,
    HitchCoupler,
    ParameterDeclarations,
    Properties,
    _BaseCatalog,
    convert_enum,
    convert_float,
    find_mandatory_field,
)


class Axle(VersionBase):
    """The Axle describes the axle properties of a vehicle.

    Parameters
    ----------
    maxsteer : float
        Maximum steering angle.
    wheeldia : float
        Diameter of the wheel.
    track_width : float
        Distance between wheel centers.
    xpos : float
        X position of the axle relative to the car reference.
    zpos : float
        Z position of the axle relative to the car reference.

    Attributes
    ----------
    maxsteer : float
        Maximum steering angle.
    wheeldia : float
        Diameter of the wheel.
    track_width : float
        Distance between wheel centers.
    xpos : float
        X position of the axle relative to the car reference.
    zpos : float
        Z position of the axle relative to the car reference.

    Methods
    -------
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    """

    def __init__(
        self,
        maxsteer: float,
        wheeldia: float,
        track_width: float,
        xpos: float,
        zpos: float,
    ):
        """Initialize the Axle.

        Parameters
        ----------
        maxsteer : float
            Maximum steering angle.
        wheeldia : float
            Diameter of the wheel.
        track_width : float
            Distance between wheel centers.
        xpos : float
            X position of the axle relative to the car reference.
        zpos : float
            Z position of the axle relative to the car reference.
        """
        self.maxsteer = convert_float(maxsteer)
        self.wheeldia = convert_float(wheeldia)
        self.track_width = convert_float(track_width)
        self.xpos = convert_float(xpos)
        self.zpos = convert_float(zpos)

    @staticmethod
    def parse(element: ET.Element) -> "Axle":
        """Parse the XML element of Axle.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An Axle element (same as generated by the class itself).

        Returns
        -------
        Axle
            An Axle object.
        """
        maxsteer = convert_float(element.attrib["maxSteering"])
        wheeldia = convert_float(element.attrib["wheelDiameter"])
        track_width = convert_float(element.attrib["trackWidth"])
        xpos = convert_float(element.attrib["positionX"])
        zpos = convert_float(element.attrib["positionZ"])
        return Axle(maxsteer, wheeldia, track_width, xpos, zpos)

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Axle):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    def get_attributes(self) -> dict:
        """Return the attributes of the Axle as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Axle.
        """
        return {
            "maxSteering": str(self.maxsteer),
            "wheelDiameter": str(self.wheeldia),
            "trackWidth": str(self.track_width),
            "positionX": str(self.xpos),
            "positionZ": str(self.zpos),
        }

    def get_element(self, elementname="AdditionalAxle"):
        """Return the ElementTree of the Axle.

        Parameters
        ----------
        elementname : str, optional
            The name of the element. Default is "AdditionalAxle".

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Axle.
        """
        return ET.Element(elementname, attrib=self.get_attributes())


class Axles(VersionBase):
    """The Axles combines the different Axles to one Element.

    Parameters
    ----------
    frontaxle : Axle
        Axle properties of the front axle.
    rearaxle : Axle
        Axle properties of the rear axle.

    Attributes
    ----------
    frontaxle : Axle
        Axle properties of the front axle.
    rearaxle : Axle
        Axle properties of the rear axle.
    additionals : list of Axle
        Additional axles if required.

    Methods
    -------
    add_axle(axle)
        Adds an additional axle to the Axles.
    get_element()
        Returns the full ElementTree of the class.
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    """

    def __init__(self, frontaxle: Axle, rearaxle: Axle):
        """Initialize the Axles.

        Parameters
        ----------
        frontaxle : Axle
            Axle properties of the front axle.
        rearaxle : Axle
            Axle properties of the rear axle.
        """
        if frontaxle and not isinstance(frontaxle, Axle):
            raise TypeError("frontaxle input is not of type Axle")
        if not isinstance(rearaxle, Axle):
            raise TypeError("rearaxle input is not of type Axle")
        self.frontaxle = frontaxle
        self.rearaxle = rearaxle
        self.additionals = []

    def __eq__(self, other: object) -> bool:
        if (
            isinstance(other, Axles)
            and self.frontaxle == other.frontaxle
            and self.rearaxle == other.rearaxle
            and self.additionals == other.additionals
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "Axles":
        """Parse the XML element of Axles.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An Axles element (same as generated by the class itself).

        Returns
        -------
        Axles
            An Axles object.
        """
        frontaxle = Axle.parse(find_mandatory_field(element, "FrontAxle"))
        rearaxle = Axle.parse(find_mandatory_field(element, "RearAxle"))
        axles = Axles(frontaxle, rearaxle)
        additionals = element.findall("AdditionalAxle")
        for additional in additionals:
            axle = Axle.parse(additional)
            axles.add_axle(axle)
        return axles

    def add_axle(self, axle: Axle):
        """Add an additional axle to the Axles.

        Parameters
        ----------
        axle : Axle
            An additional Axle.
        """
        if not isinstance(axle, Axle):
            raise TypeError("axle input is not of type Axle")
        self.additionals.append(axle)
        return self

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the Axles.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Axles.
        """
        element = ET.Element("Axles")
        if self.frontaxle is None and self.isVersionEqLess(minor=2):
            raise OpenSCENARIOVersionError(
                "A front axle is required for OSC versions up to 1.2."
            )
        if self.frontaxle:
            element.append(self.frontaxle.get_element(elementname="FrontAxle"))
        element.append(self.rearaxle.get_element(elementname="RearAxle"))
        for ax in self.additionals:
            element.append(ax.get_element())

        return element


class Entity(VersionBase):
    """The Entity class creates an Entity of OpenScenario. Can either use an
    object_type or entityref (not both).

    Parameters
    ----------
    name : str
        Name of the Entity.
    object_type : ObjectType or list of ObjectType, optional
        The object_type to be used.
    entityref : str, optional
        Reference to an entity.

    Attributes
    ----------
    name : str
        Name of the Entity.
    object_type : ObjectType
        The object_type to be used.
    entityref : str
        Reference to an entity.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    """

    def __init__(
        self,
        name: str,
        object_type: Optional[ObjectType] = None,
        entityref: Optional[str] = None,
    ):
        """Initialize the Entity.

        Parameters
        ----------
        name : str
            Name of the Entity.
        object_type : ObjectType, optional
            The object_type to be used.
        entityref : str, optional
            Reference to an entity.
        """
        self.name = name
        self.object_type = []
        self.entity = []
        if (object_type is not None) and (entityref is not None):
            raise KeyError("only one of objecttype or entityref are alowed")
        if (object_type is None) and (entityref is None):
            raise KeyError("either objecttype or entityref is requiered")
        if entityref:
            if isinstance(entityref, list):
                self.entity = [EntityRef(x) for x in entityref]
            else:
                self.entity.append(EntityRef(entityref))
            self.object_type = None
        else:
            if isinstance(object_type, list):
                self.object_type = [
                    convert_enum(x, ObjectType) for x in object_type
                ]
            else:
                self.object_type.append(convert_enum(object_type, ObjectType))
            self.entity = None

    def __eq__(self, other: object) -> bool:
        if (
            isinstance(other, Entity)
            and self.get_attributes() == other.get_attributes()
            and self.object_type == other.object_type
            and self.entity == other.entity
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "Entity":
        """Parse the XML element of Entity.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An Entity element (same as generated by the class itself).

        Returns
        -------
        Entity
            An Entity object.
        """
        name = element.attrib["name"]
        bytypes = []
        entity_refs = []

        members_element = find_mandatory_field(element, "Members")
        if members_element.find("ByType") is not None:
            types = members_element.findall("ByType")
            for t in types:
                bytypes.append(
                    convert_enum(t.attrib["objectType"], ObjectType)
                )
            entity_refs = None
        elif members_element.find("EntityRef") is not None:
            entities = members_element.findall("EntityRef")
            for entity in entities:
                entity_refs.append(entity.attrib["entityRef"])
            bytypes = None

        return Entity(name, object_type=bytypes, entityref=entity_refs)

    def get_attributes(self) -> dict:
        """Return the attributes of the Entity as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Entity.
        """
        return {"name": self.name}

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the Entity.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Entity.
        """
        element = ET.Element("EntitySelection", attrib=self.get_attributes())
        members = ET.SubElement(element, "Members")
        if self.entity:
            for entity in self.entity:
                members.append(entity.get_element())
        if self.object_type:
            for object_type in self.object_type:
                ET.SubElement(
                    members,
                    "ByType",
                    attrib={"objectType": object_type.get_name()},
                )
        return element


class Pedestrian(_BaseCatalog):
    """The Pedestrian class creates a pedestrian type entity of OpenScenario.

    Parameters
    ----------
    name : str
        Name of the type (required for catalog).
    mass : float
        Mass of the pedestrian.
    boundingbox : BoundingBox
        The bounding box of the pedestrian.
    category : PedestrianCategory
        Type of pedestrian.
    model : str, optional
        Definition model of the pedestrian. Default is None.
    role : Role, optional
        The role of the Pedestrian (valid from OpenSCENARIO V1.2).
        Default is None.

    Attributes
    ----------
    name : str
        Name of the pedestrian.
    model : str
        Definition model of the pedestrian.
    mass : float
        Mass of the pedestrian.
    category : PedestrianCategory
        Type of pedestrian.
    boundingbox : BoundingBox
        The bounding box of the pedestrian.
    parameters : ParameterDeclaration
        Parameter declarations of the pedestrian.
    properties : Properties
        Additional properties of the pedestrian.
    role : Role
        The role of the Pedestrian.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class itself.
    add_parameter(parameter)
        Adds a parameter declaration to the pedestrian.
    add_property(name, value)
        Adds a single property to the pedestrian.
    add_property_file(filename)
        Adds a property file to the pedestrian.
    append_to_catalog(filename)
        Adds the pedestrian to an existing catalog.
    dump_to_catalog(filename, name, description, author)
        Creates a new catalog with the pedestrian.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    """

    def __init__(
        self,
        name: str,
        mass: float,
        category: PedestrianCategory,
        boundingbox: BoundingBox,
        model: Optional[str] = None,
        role: Optional[Role] = None,
    ):
        """Initialize the Pedestrian class.

        Parameters
        ----------
        name : str
            Name of the type (required for catalog).
        mass : float
            Mass of the pedestrian.
        category : PedestrianCategory
            Type of pedestrian.
        boundingbox : BoundingBox
            The bounding box of the pedestrian.
        model : str, optional
            Definition model of the pedestrian. Default is None.
        role : Role, optional
            The role of the Pedestrian (valid from OpenSCENARIO V1.2).
            Default is None.
        """
        super().__init__()
        self.name = name
        self.model = model
        self.mass = convert_float(mass)

        self.category = convert_enum(category, PedestrianCategory)
        if not isinstance(boundingbox, BoundingBox):
            raise TypeError("boundingbox input is not of type BoundingBox")

        self.boundingbox = boundingbox
        self.properties = Properties()
        self.role = convert_enum(role, Role, True)

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Pedestrian):
            if (
                self.get_attributes() == other.get_attributes()
                and self.boundingbox == other.boundingbox
                and self.properties == other.properties
                and self.parameters == other.parameters
                and self.role == other.role
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "Pedestrian":
        """Parse the XML element of Pedestrian.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A Pedestrian element (same as generated by the class itself).

        Returns
        -------
        Pedestrian
            A Pedestrian object.
        """
        name = element.attrib["name"]
        mass = convert_float(element.attrib["mass"])
        model = None
        if "model3d" in element.attrib:
            model = element.attrib["model3d"]
        elif "model" in element.attrib:
            model = element.attrib["model"]
        category = convert_enum(
            element.attrib["pedestrianCategory"], PedestrianCategory
        )
        if element.find("ParameterDeclarations") is not None:
            parameters = ParameterDeclarations.parse(
                find_mandatory_field(element, "ParameterDeclarations")
            )
        else:
            parameters = ParameterDeclarations()
        boundingbox = BoundingBox.parse(
            find_mandatory_field(element, "BoundingBox")
        )
        properties = None
        if element.find("Properties") is not None:
            properties = Properties.parse(
                find_mandatory_field(element, "Properties")
            )
        role = None
        if "role" in element.attrib:
            role = convert_enum(element.attrib["role"], Role)
        pedestrian = Pedestrian(name, mass, category, boundingbox, model, role)
        pedestrian.parameters = parameters
        if properties is not None:
            pedestrian.properties = properties

        return pedestrian

    def add_property(self, name: str, value: str):
        """Add a single property to the pedestrian.

        Parameters
        ----------
        name : str
            Name of the property.
        value : str
            Value of the property.
        """
        self.properties.add_property(name, value)
        return self

    def add_property_file(self, filename: str):
        """Add a property file to the pedestrian.

        Parameters
        ----------
        filename : str
            Filename of a property file.
        """
        self.properties.add_file(filename)
        return self

    def get_attributes(self) -> dict:
        """Return the attributes as a dictionary of the pedestrian.

        Returns
        -------
        dict
            A dictionary containing the attributes of the pedestrian.
        """
        retdict = {}
        retdict["name"] = str(self.name)
        retdict["pedestrianCategory"] = self.category.get_name()

        if self.isVersion(minor=0) and self.model is None:
            raise OpenSCENARIOVersionError("model is required for OSC 1.0")

        if self.model is not None and self.isVersionEqLess(minor=2):
            if self.isVersion(minor=0):
                retdict["model"] = self.model
            else:
                retdict["model3d"] = self.model
        retdict["mass"] = str(self.mass)
        if self.role:
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(
                    "role for Pedestrian was added in OSC V1.2"
                )
            retdict["role"] = self.role.get_name()
        return retdict

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the pedestrian.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the pedestrian.
        """
        element = ET.Element("Pedestrian", attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        element.append(self.boundingbox.get_element())
        prop_obj = self.properties.get_element()
        if prop_obj is not None:
            element.append(prop_obj)

        return element


class MiscObject(_BaseCatalog):
    """The MiscObject class creates a MiscObject for OpenScenario.

    Parameters
    ----------
    name : str
        Name of the MiscObject.
    mass : float
        Mass of the object.
    category : MiscObjectCategory
        The category of the misc object.
    boundingbox : BoundingBox
        The bounding box of the MiscObject.
    model3d : str, optional
        Path to model file (valid from V1.1). Default is None.

    Attributes
    ----------
    name : str
        Name of the object.
    mass : float
        Mass of the object.
    misc_type : MiscObjectCategory
        Type of misc object.
    boundingbox : BoundingBox
        The bounding box of the MiscObject.
    parameters : ParameterDeclaration
        Parameter declarations of the MiscObject.
    properties : Properties
        Additional properties of the MiscObject.
    model3d : str
        Path to model file (valid from V1.1). Default is None.

    Methods
    -------
    add_parameter(parameter)
        Adds a parameter declaration to the MiscObject.
    add_property(name, value)
        Adds a single property to the MiscObject.
    add_property_file(filename)
        Adds a property file to the MiscObject.
    append_to_catalog(filename)
        Adds the MiscObject to an existing catalog.
    dump_to_catalog(filename, name, description, author)
        Creates a new catalog with the MiscObject.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    """

    def __init__(
        self,
        name: str,
        mass: float,
        category: MiscObjectCategory,
        boundingbox: BoundingBox,
        model3d: Optional[str] = None,
    ):
        """Initialize the MiscObject class.

        Parameters
        ----------
        name : str
            Name of the MiscObject.
        mass : float
            Mass of the object.
        category : MiscObjectCategory
            The category of the misc object.
        boundingbox : BoundingBox
            The bounding box of the MiscObject.
        model3d : str, optional
            Path to model file (valid from V1.1). Default is None.
        """
        super().__init__()
        self.name = name
        self.mass = convert_float(mass)
        self.category = convert_enum(category, MiscObjectCategory)
        if not isinstance(boundingbox, BoundingBox):
            raise TypeError("boundingbox input is not of type BoundingBox")
        self.boundingbox = boundingbox
        self.properties = Properties()
        self.model3d = model3d

    def __eq__(self, other: object) -> bool:
        if (
            isinstance(other, MiscObject)
            and self.get_attributes() == other.get_attributes()
            and self.boundingbox == other.boundingbox
            and self.properties == other.properties
            and self.parameters == other.parameters
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "MiscObject":
        """Parse the XML element to MiscObject.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A MiscObject element (same as generated by the class itself).

        Returns
        -------
        MiscObject
            A MiscObject object.
        """
        model3d = None
        if "model3d" in element.attrib:
            model3d = element.attrib["model3d"]
        mass = convert_float(element.attrib["mass"])
        name = element.attrib["name"]
        properties = None
        if element.find("Properties") is not None:
            properties = Properties.parse(
                find_mandatory_field(element, "Properties")
            )
        boundingbox = BoundingBox.parse(
            find_mandatory_field(element, "BoundingBox")
        )
        category = convert_enum(
            element.attrib["miscObjectCategory"], MiscObjectCategory
        )

        if element.find("ParameterDeclarations") is not None:
            parameters = ParameterDeclarations.parse(
                find_mandatory_field(element, "ParameterDeclarations")
            )
        else:
            parameters = ParameterDeclarations()

        obj = MiscObject(name, mass, category, boundingbox, model3d)
        obj.parameters = parameters
        if properties is not None:
            obj.properties = properties
        return obj

    def add_property(self, name: str, value: str):
        """Add a single property to the MiscObject.

        Parameters
        ----------
        name : str
            Name of the property.
        value : str
            Value of the property.
        """
        self.properties.add_property(name, value)

    def add_property_file(self, filename: str) -> None:
        """Add a property file to the MiscObject.

        Parameters
        ----------
        filename : str
            Filename of a property file.
        """
        self.properties.add_file(filename)

    def get_attributes(self) -> dict:
        """Return the attributes as a dictionary of the MiscObject.

        Returns
        -------
        dict
            A dictionary containing the attributes of the MiscObject.
        """
        retdict = {}
        retdict["name"] = str(self.name)
        retdict["miscObjectCategory"] = self.category.get_name()
        retdict["mass"] = str(self.mass)
        if not self.isVersion(minor=0) and self.model3d:
            retdict["model3d"] = self.model3d
        return retdict

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the MiscObject.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the MiscObject.
        """
        element = ET.Element("MiscObject", attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        element.append(self.boundingbox.get_element())
        prop_obj = self.properties.get_element()
        if prop_obj is not None:
            element.append(prop_obj)

        return element


class Vehicle(_BaseCatalog):
    """The Vehicle class creates a Vehicle for OpenScenario.

    Parameters
    ----------
    name : str
        Name of the vehicle.
    vehicle_type : VehicleCategory
        Type of vehicle.
    boundingbox : BoundingBox
        The bounding box of the vehicle.
    frontaxle : Axle
        The front axle properties of the vehicle.
        (optional since OpenScenario V1.3)
    rearaxle : Axle
        The back axle properties of the vehicle.
    max_speed : float
        The maximum speed of the vehicle.
    max_acceleration : float
        The maximum acceleration of the vehicle.
    max_deceleration : float
        The maximum deceleration of the vehicle.
    mass : float, optional
        The mass of the vehicle (valid from OpenSCENARIO V1.1).
        Default is None.
    model3d : str, optional
        Path to model file (valid from V1.1). Default is None.
    max_acceleration_rate : float, optional
        The maximum acceleration rate (jerk) of the vehicle (valid from
        OpenSCENARIO V1.2). Default is None.
    max_deceleration_rate : float, optional
        The maximum acceleration rate (jerk) of the vehicle (valid from
        OpenSCENARIO V1.2). Default is None.
    role : Role, optional
        The role of the Vehicle (valid from OpenSCENARIO V1.2). Default
        is None.
    trailer_hitch : HitchCoupler, optional
        Add an optional hitch to the vehicle, Default: None
    trailer_coupler : HitchCoupler, optional
        Add an optional coupler to the vehicle, Default: None
    trailer : ScenarioObject | EntitiyRef
        Add a scenario object or a name of a scenario object,
        Default: None
    Attributes
    ----------
    name : str
        Name of the vehicle.
    vehicle_type : VehicleCategory
        Type of vehicle.
    boundingbox : BoundingBox
        The bounding box of the vehicle.
    axles : Axles
        An Axles object.
    dynamics : DynamicsConstraints
        The allowed dynamics of the vehicle.
    parameters : ParameterDeclaration
        Parameter declarations of the vehicle.
    properties : Properties
        Additional properties of the vehicle.
    mass : float
        The mass of the vehicle.
    model3d : str
        Path to model file (valid from V1.1).
    role : Role
        The role of the Vehicle.
    trailer_hitch : HitchCoupler, optional
        Add an optional hitch to the vehicle
    trailer_coupler : HitchCoupler, optional
        Add an optional coupler to the vehicle
    trailer : ScenarioObject | str
        A scenario object or a name of a scenario object

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class itself.
    add_axle(axle)
        Adds an additional axle to the vehicle.
    add_parameter(parameter)
        Adds a parameter declaration to the vehicle.
    add_property(name, value)
        Adds a single property to the vehicle.
    add_property_file(filename)
        Adds a property file to the vehicle.
    append_to_catalog(filename)
        Adds the vehicle to an existing catalog.
    dump_to_catalog(filename, name, description, author)
        Creates a new catalog with the vehicle.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns a dictionary of all attributes of the class.
    """

    def __init__(
        self,
        name: str,
        vehicle_type: VehicleCategory,
        boundingbox: BoundingBox,
        frontaxle: Optional[Axle],
        rearaxle: Axle,
        max_speed: float,
        max_acceleration: float,
        max_deceleration: float,
        mass: Optional[float] = None,
        model3d: Optional[str] = None,
        max_acceleration_rate: Optional[float] = None,
        max_deceleration_rate: Optional[float] = None,
        role: Optional[Role] = None,
        trailer_hitch: Optional[HitchCoupler] = None,
        trailer_coupler: Optional[HitchCoupler] = None,
        trailer: Union[Optional[str], "ScenarioObject"] = None,
    ):
        """Initialize the Vehicle class.

        Parameters
        ----------
        name : str
            Name of the vehicle.
        vehicle_type : VehicleCategory
            Type of vehicle.
        boundingbox : BoundingBox
            The bounding box of the vehicle.
        frontaxle : Axle
            The front axle properties of the vehicle.
        rearaxle : Axle
            The back axle properties of the vehicle.
        max_speed : float
            The maximum speed of the vehicle.
        max_acceleration : float
            The maximum acceleration of the vehicle.
        max_deceleration : float
            The maximum deceleration of the vehicle.
        mass : float, optional
            The mass of the vehicle (valid from OpenSCENARIO V1.1).
            Default is None.
        model3d : str, optional
            Path to model file (valid from V1.1). Default is None.
        max_acceleration_rate : float, optional
            The maximum acceleration rate (jerk) of the vehicle (valid
            from OpenSCENARIO V1.2). Default is None.
        max_deceleration_rate : float, optional
            The maximum acceleration rate (jerk) of the vehicle (valid
            from OpenSCENARIO V1.2). Default is None.
        role : Role, optional
            The role of the Vehicle (valid from OpenSCENARIO V1.2).
            Default is None.
        trailer_hitch : HitchCoupler, optional
            Add an optional hitch to the vehicle, Default: None
        trailer_coupler : HitchCoupler, optional
            Add an optional coupler to the vehicle, Default: None
        trailer : ScenarioObject | EntitiyRef
            Add a scenario object or a name of a scenario object,
            Default: None
        """
        super().__init__()
        self.name = name
        if not isinstance(boundingbox, BoundingBox):
            raise TypeError("boundingbox input is not of type BoundingBox")

        self.vehicle_type = convert_enum(vehicle_type, VehicleCategory)
        self.boundingbox = boundingbox

        self.axles = Axles(frontaxle, rearaxle)
        self.dynamics = DynamicsConstraints(
            max_acceleration,
            max_deceleration,
            max_speed,
            max_acceleration_rate,
            max_deceleration_rate,
        )
        self.properties = Properties()
        self.mass = convert_float(mass)
        self.model3d = model3d
        self.role = convert_enum(role, Role, True)
        if trailer_hitch is not None and not isinstance(
            trailer_hitch, HitchCoupler
        ):
            raise TypeError("trailer hitch is not of type HitchCoupler")
        if trailer_coupler is not None and not isinstance(
            trailer_coupler, HitchCoupler
        ):
            raise TypeError("trailer hitch is not of type HitchCoupler")
        if trailer is not None and not isinstance(
            trailer, (str, ScenarioObject)
        ):
            raise TypeError("trailer is not of type str or ScenarioObject")
        self.trailer_hitch = trailer_hitch
        self.trailer_coupler = trailer_coupler
        self.trailer = trailer

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Vehicle):
            if (
                self.get_attributes() == other.get_attributes()
                and self.boundingbox == other.boundingbox
                and self.properties == other.properties
                and self.axles == other.axles
                and self.dynamics == other.dynamics
                and self.parameters == other.parameters
                and self.mass == other.mass
                and self.role == other.role
                and self.trailer_coupler == other.trailer_coupler
                and self.trailer_hitch == other.trailer_hitch
                and self.trailer == other.trailer
            ):
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "Vehicle":
        """Parse the XML element of Vehicle.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A vehicle element (same as generated by the class itself).

        Returns
        -------
        Vehicle
            A Vehicle object.
        """
        name = element.attrib["name"]
        mass = None
        if "mass" in element.attrib:
            mass = convert_float(element.attrib["mass"])
        vehicle_type = convert_enum(
            element.attrib["vehicleCategory"], VehicleCategory
        )
        model3d = None
        if "model3d" in element.attrib:
            model3d = element.attrib["model3d"]
        if element.find("ParameterDeclarations") is not None:
            parameters = ParameterDeclarations.parse(
                find_mandatory_field(element, "ParameterDeclarations")
            )
        else:
            parameters = ParameterDeclarations()
        boundingbox = BoundingBox.parse(
            find_mandatory_field(element, "BoundingBox")
        )
        properties = None
        if element.find("Properties") is not None:
            properties = Properties.parse(
                find_mandatory_field(element, "Properties")
            )

        performance = DynamicsConstraints.parse(
            find_mandatory_field(element, "Performance")
        )
        max_speed = performance.max_speed
        max_acc = performance.max_acceleration
        max_dec = performance.max_deceleration
        max_acc_rate = performance.max_acceleration_rate
        max_dec_rate = performance.max_deceleration_rate

        axles_element = find_mandatory_field(element, "Axles")
        frontaxle = Axle.parse(
            find_mandatory_field(axles_element, "FrontAxle")
        )
        rearaxle = Axle.parse(find_mandatory_field(axles_element, "RearAxle"))

        role = None
        if "role" in element.attrib:
            role = convert_enum(element.attrib["role"], Role)

        trailer_hitch = None
        trailer_coupler = None
        trailer = None
        if element.find("TrailerHitch") is not None:
            trailer_hitch = HitchCoupler.parse(
                find_mandatory_field(element, "TrailerHitch")
            )
        if element.find("TrailerCoupler") is not None:
            trailer_coupler = HitchCoupler.parse(
                find_mandatory_field(element, "TrailerCoupler")
            )
        if element.find("Trailer") is not None:
            trailer_element = find_mandatory_field(element, "Trailer")
            if trailer_element.find("Trailer"):
                trailer = ScenarioObject.parse(
                    find_mandatory_field(trailer_element, "Trailer")
                )
            else:
                trailer = EntityRef.parse(
                    find_mandatory_field(trailer_element, "TrailerRef")
                ).entity

        vehicle = Vehicle(
            name,
            vehicle_type,
            boundingbox,
            frontaxle,
            rearaxle,
            max_speed,
            max_acc,
            max_dec,
            mass,
            model3d,
            max_acc_rate,
            max_dec_rate,
            role,
            trailer_hitch,
            trailer_coupler,
            trailer,
        )
        if properties is not None:
            vehicle.properties = properties
        vehicle.parameters = parameters

        additional_axles = axles_element.findall("AdditionalAxle")
        if additional_axles is not None:
            for axle in additional_axles:
                vehicle.axles.add_axle(Axle.parse(axle))

        return vehicle

    def add_axle(self, axle: Axle) -> None:
        """Add an additional axle to the vehicle.

        Parameters
        ----------
        axle : Axle
            An additional Axle.
        """
        self.axles.add_axle(axle)
        return self

    def add_property(self, name: str, value: str) -> None:
        """Add a single property to the vehicle.

        Parameters
        ----------
        name : str
            Name of the property.
        value : str
            Value of the property.
        """
        self.properties.add_property(name, value)
        return self

    def add_property_file(self, filename: str) -> None:
        """Add a property file to the vehicle.

        Parameters
        ----------
        filename : str
            Filename of a property file.
        """
        self.properties.add_file(filename)
        return self

    def get_attributes(self) -> dict:
        """Return the attributes as a dictionary of the Vehicle.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Vehicle.
        """
        retdict = {}
        retdict["name"] = str(self.name)
        retdict["vehicleCategory"] = self.vehicle_type.get_name()
        if self.mass:
            if self.isVersion(minor=0):
                raise OpenSCENARIOVersionError(
                    "Mass of a vehcile was introduced in OSC 1.1"
                )
            retdict["mass"] = str(self.mass)
        if self.model3d:
            if self.isVersion(minor=0):
                raise OpenSCENARIOVersionError(
                    "model3d of a vehcile was introduced in OSC 1.1"
                )
            retdict["model3d"] = self.model3d
        if self.role:
            if self.isVersionEqLess(minor=1):
                raise OpenSCENARIOVersionError(
                    "the role of a vehcile was introduced in OSC 1.1"
                )
            retdict["role"] = self.role.get_name()

        return retdict

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the Vehicle.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Vehicle.
        """
        element = ET.Element("Vehicle", attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        element.append(self.boundingbox.get_element())
        element.append(self.dynamics.get_element("Performance"))
        element.append(self.axles.get_element())
        prop_obj = self.properties.get_element()
        if prop_obj is not None:
            element.append(prop_obj)
        if self.trailer_hitch:
            element.append(self.trailer_hitch.get_element("Hitch"))
        if self.trailer_coupler:
            element.append(self.trailer_coupler.get_element("Coupler"))
        if self.trailer is not None:

            trailer_element = ET.SubElement(element, "Trailer")
            if isinstance(self.trailer, str):
                trailer_element.append(
                    EntityRef(self.trailer).get_element("TrailerRef")
                )
            else:
                trailer_element.append(self.trailer.get_element("Trailer"))
        return element


class ExternalObjectReference(VersionBase):
    """The ExternalObjectReference describes the EntityObject
    ExternalObjectReference (valid from V1.1).

    Parameters
    ----------
    name : str
        Identifier of the external object.

    Attributes
    ----------
    name : str
        Identifier of the external object.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    """

    def __init__(self, name: str):
        """Initialize the ExternalObjectReference.

        Parameters
        ----------
        name : str
            Identifier of the external object.
        """
        self.name = name

    def __eq__(self, other: object) -> bool:
        if isinstance(other, ExternalObjectReference):
            if self.get_attributes() == other.get_attributes():
                return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "ExternalObjectReference":
        """Parse the XML element of ExternalObjectReference.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An ExternalObjectReference element (same as generated by the
            class itself).

        Returns
        -------
        ExternalObjectReference
            An ExternalObjectReference object.
        """
        name = element.attrib["name"]
        return ExternalObjectReference(name)

    def get_attributes(self) -> dict:
        """Return the attributes of the Axle as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Axle.
        """
        return {"name": self.name}

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the Axle.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Axle.
        """
        if self.isVersion(minor=0):
            raise OpenSCENARIOVersionError(
                "ExternalObjectReference was introduced in OSC 1.1"
            )
        return ET.Element(
            "ExternalObjectReference", attrib=self.get_attributes()
        )


class Entities(VersionBase):
    """The Entities class creates the entities part of OpenScenario.

    Attributes
    ----------
    scenario_objects : list of ScenarioObject
        ScenarioObject type entities in the scenario.
    entities : list of Entity
        Entity type of entities in the scenario.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    add_scenario_object(entityobject,controller)
        Adds a ScenarioObject to the scenario.
    add_entity_bytype(name,entity_type)
        Adds an Entity by the type of entity.
    add_entity_byref(name,reference)
        Adds an Entity by a reference name.
    get_element()
        Returns the full ElementTree of the class.
    """

    def __init__(self):
        """Initialize the Entities class."""
        self.scenario_objects = []
        self.entities = []

    def __eq__(self, other: object) -> bool:
        if (
            isinstance(other, Entities)
            and self.scenario_objects == other.scenario_objects
            and self.entities == other.entities
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "Entities":
        """Parse the XML element of Entities.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            An entities element (same as generated by the class itself).

        Returns
        -------
        Entities
            An Entities object.
        """
        ent_ret = Entities()
        scenario_objects = []
        entity_selections = []
        if element.find("ScenarioObject") is not None:
            for obj in element.findall("ScenarioObject"):
                scenario_objects.append(ScenarioObject.parse(obj))
        if element.find("EntitySelection") is not None:
            for entity in element.findall("EntitySelection"):
                entity_selections.append(Entity.parse(entity))

        ent_ret.entities = entity_selections
        ent_ret.scenario_objects = scenario_objects
        return ent_ret

    def add_scenario_object(
        self,
        name: str,
        entityobject: Union[
            CatalogReference,
            Vehicle,
            Pedestrian,
            MiscObject,
            ExternalObjectReference,
        ],
        controller: Optional[
            Union[
                CatalogReference,
                Controller,
                list[CatalogReference],
                list[Controller],
            ]
        ] = None,
    ) -> None:
        """Add a ScenarioObject to the scenario.

        Parameters
        ----------
        name : str
            Name of the scenario object.
        entityobject : CatalogReference, Vehicle, Pedestrian, MiscObject,
            or ExternalObjectReference (V1.1)
            Object description.
        controller : CatalogReference, Controller, or list of
            CatalogReference/Controller, optional
            Controller for the object. Default is None.
        """
        self.scenario_objects.append(
            ScenarioObject(name, entityobject, controller)
        )
        return self

    def add_entity_bytype(
        self, name: str, object_type: Union[ObjectType, list[ObjectType]]
    ) -> None:
        """Add an Entity to the scenario.

        Parameters
        ----------
        name : str
            Name of the entity.
        object_type : ObjectType or list of ObjectType
            Type of entity.
        """
        self.entities.append(Entity(name, object_type=object_type))
        return self

    def add_entity_byref(self, name: str, entity: str) -> None:
        """Add an Entity to the scenario.

        Parameters
        ----------
        name : str
            Name of the entity.
        entity : str
            Type of entity.
        """
        self.entities.append(Entity(name, entityref=entity))
        return self

    def get_element(self) -> ET.Element:
        """Return the ElementTree of the Entities.

        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Entities.
        """
        element = ET.Element("Entities")
        for i in self.scenario_objects:
            element.append(i.get_element())

        for i in self.entities:
            element.append(i.get_element())

        return element


class ScenarioObject(VersionBase):
    """The ScenarioObject creates a scenario object of OpenScenario.

    Parameters
    ----------
    name : str
        Name of the object.
    entityobject : CatalogReference, Vehicle, Pedestrian, MiscObject, or
        ExternalObjectReference
        Object description.
    controller : CatalogReference, Controller, or list of
        CatalogReference/Controller, optional
        Controller for the object. Default is None.

    Attributes
    ----------
    name : str
        Name of the object.
    entityobject : CatalogReference, Vehicle, Pedestrian, MiscObject, or
        ExternalObjectReference
        Object description.
    controller : list of CatalogReference/Controller
        Controller for the object.

    Methods
    -------
    parse(element)
        Parses an ElementTree created by the class and returns an
        instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    get_attributes()
        Returns the attributes of the class.
    """

    def __init__(
        self,
        name: str,
        entityobject: Union[
            CatalogReference,
            Vehicle,
            Pedestrian,
            MiscObject,
            ExternalObjectReference,
        ],
        controller: Union[
            Optional[CatalogReference],
            Controller,
            list[CatalogReference],
            list[Controller],
        ] = None,
    ):
        """Initialize the ScenarioObject.

        Parameters
        ----------
        name : str
            Name of the object.
        entityobject : CatalogReference, Vehicle, Pedestrian, MiscObject,
            or ExternalObjectReference
            Object description.
        controller : CatalogReference, Controller, or list of
            CatalogReference/Controller, optional
            Controller for the object (multiple controllers are valid
            since OSC V1.2). Default is None.
        """
        self.name = name
        if not (
            isinstance(
                entityobject,
                (CatalogReference, Vehicle, Pedestrian, MiscObject),
            )
            or (
                not self.isVersion(minor=0)
                and isinstance(entityobject, ExternalObjectReference)
            )
        ):
            raise TypeError(
                "entityobject is not of type CatalogReference, Vehicle, "
                "Pedestrian, MiscObject, nor ExternalObjectReference (or "
                "to old version of openscenario)"
            )

        if controller is not None:
            if not isinstance(controller, list):
                self.controller = [controller]
            else:
                self.controller = controller

            for cnt in self.controller:
                if cnt is not None and not isinstance(
                    cnt, (CatalogReference, Controller)
                ):
                    raise TypeError(
                        "controller input is not of type CatalogReference "
                        "or Controller"
                    )
        else:
            self.controller = controller
        self.entityobject = entityobject

    def __eq__(self, other: object) -> bool:
        if (
            isinstance(other, ScenarioObject)
            and self.get_attributes() == other.get_attributes()
            and self.controller == other.controller
            and self.entityobject == other.entityobject
        ):
            return True
        return False

    @staticmethod
    def parse(element: ET.Element) -> "ScenarioObject":
        """Parse the XML element of ScenarioObject.

        Parameters
        ----------
        element : xml.etree.ElementTree.Element
            A scenarioobject element (same as generated by the class
            itself).

        Returns
        -------
        ScenarioObject
            A ScenarioObject object.
        """
        name = element.attrib["name"]
        if element.find("CatalogReference") is not None:
            entityobject = CatalogReference.parse(
                find_mandatory_field(element, "CatalogReference")
            )
        elif element.find("Vehicle") is not None:
            entityobject = Vehicle.parse(
                find_mandatory_field(element, "Vehicle")
            )
        elif element.find("Pedestrian") is not None:
            entityobject = Pedestrian.parse(
                find_mandatory_field(element, "Pedestrian")
            )
        elif element.find("MiscObject") is not None:
            entityobject = MiscObject.parse(
                find_mandatory_field(element, "MiscObject")
            )
        elif element.find("ExternalObjectReference") is not None:
            entityobject = ExternalObjectReference.parse(
                find_mandatory_field(element, "ExternalObjectReference")
            )
        else:
            raise XMLStructureError(
                "ScenarioObject does not contain a valid "
                "CatalogReference, Vehicle, Pedestrian, MiscObject, or "
                "ExternalObjectReference"
            )

        controller = None
        if element.find("ObjectController") is not None:
            controller = []
            for object_controller_element in element.findall(
                "ObjectController"
            ):
                if object_controller_element.find("Controller") is not None:
                    controller.append(
                        Controller.parse(
                            find_mandatory_field(
                                object_controller_element, "Controller"
                            )
                        )
                    )
                elif (
                    find_mandatory_field(
                        object_controller_element, "CatalogReference"
                    )
                    is not None
                ):
                    controller.append(
                        CatalogReference.parse(
                            find_mandatory_field(
                                object_controller_element, "CatalogReference"
                            )
                        )
                    )

        return ScenarioObject(name, entityobject, controller)

    def get_attributes(self) -> dict:
        """Return the attributes of the Entity as a dictionary.

        Returns
        -------
        dict
            A dictionary containing the attributes of the Entity.
        """
        return {"name": self.name}

    def get_element(self, elementname: str = "ScenarioObject") -> ET.Element:
        """Return the ElementTree of the Entity.

        Parameters
        ----------
        elementname : str
            Used if another name is needed for the ScenarioObject. Default is
            "ScenarioObject".
        Returns
        -------
        xml.etree.ElementTree.Element
            The ElementTree representation of the Entity.
        """
        element = ET.Element(elementname, attrib=self.get_attributes())

        element.append(self.entityobject.get_element())
        if self.controller:
            if self.isVersionEqLess(minor=1) and len(self.controller) > 1:
                raise OpenSCENARIOVersionError(
                    "multiple controllers were added in OSC V1.2"
                )

            for cnt in self.controller:
                objcont = ET.SubElement(element, "ObjectController")
                objcont.append(cnt.get_element())

        return element


class EntityDistribution(VersionBase):
    """The EntityDistribution class creates the entity distribution
    for OpenScenario.

    Attributes
    ----------
    entity_distribution_entries :
        List of EntityDistributionEntry objects.

    Methods
    -------
    add_entity_distribution_entry(weight, entityobject, controller=None)
        Adds an EntityDistributionEntry to the EntityDistribution.
    parse(element)
        Parses an ElementTree created by the class and returns
        an instance of the class.
    get_element()
        Returns the full ElementTree of the class.
    """

    _EntityDistributionEntry = namedtuple(
        "EntityDistributionEntry", "weight, entityobject controller"
    )

    def __init__(self):
        self.entity_distribution_entries = []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, EntityDistribution)
            and self.entity_distribution_entries
            == other.entity_distribution_entries
        )

    def add_entity_distribution_entry(
        self,
        weight: float,
        entityobject: Union[
            CatalogReference,
            Vehicle,
            Pedestrian,
        ],
        controller: Union[
            Optional[CatalogReference],
            Controller,
            list[CatalogReference],
            list[Controller],
        ] = None,
    ):
        weight = convert_float(weight)
        if weight < 0:
            raise ValueError("Weight must be a non-negative value")

        if not isinstance(
            entityobject, (CatalogReference, Vehicle, Pedestrian)
        ):
            raise TypeError(
                "entityobject must be of type CatalogReference, Vehicle, or Pedestrian"
            )

        if controller is not None:
            if not isinstance(controller, list):
                controller = [controller]
            for cnt in controller:
                if cnt is not None and not isinstance(
                    cnt, (CatalogReference, Controller)
                ):
                    raise TypeError(
                        "controller input is not of type CatalogReference or Controller"
                    )

        self.entity_distribution_entries.append(
            self._EntityDistributionEntry(weight, entityobject, controller)
        )

    @staticmethod
    def parse(element: ET.Element) -> "EntityDistribution":
        """Parses the XML element of EntityDistribution.

        Parameters
        ----------
        element : ET.Element
            An EntityDistribution element.

        Returns
        -------
        EntityDistribution
            An EntityDistribution object.
        """
        print(element.find("ObjectController"))
        ed = EntityDistribution()
        for entry_el in element.findall("EntityDistributionEntry"):
            weight = float(entry_el.attrib["weight"])
            scenario_object_template_el = entry_el.find(
                "ScenarioObjectTemplate"
            )
            # Try all possible entity object types
            entityobject = None
            if (
                scenario_object_template_el.find("CatalogReference")
                is not None
            ):
                entityobject = CatalogReference.parse(
                    scenario_object_template_el.find("CatalogReference")
                )
            elif scenario_object_template_el.find("Vehicle") is not None:
                entityobject = Vehicle.parse(
                    scenario_object_template_el.find("Vehicle")
                )
            elif scenario_object_template_el.find("Pedestrian") is not None:
                entityobject = Pedestrian.parse(
                    scenario_object_template_el.find("Pedestrian")
                )
            else:
                raise XMLStructureError(
                    "EntityDistributionEntry does not contain a valid EntityObject"
                )

            controller = None
            if (
                scenario_object_template_el.find("ObjectController")
                is not None
            ):
                controller = []
                for (
                    object_controller_element
                ) in scenario_object_template_el.findall("ObjectController"):
                    if (
                        object_controller_element.find("Controller")
                        is not None
                    ):
                        controller.append(
                            Controller.parse(
                                find_mandatory_field(
                                    object_controller_element, "Controller"
                                )
                            )
                        )
                    elif (
                        find_mandatory_field(
                            object_controller_element, "CatalogReference"
                        )
                        is not None
                    ):
                        controller.append(
                            CatalogReference.parse(
                                find_mandatory_field(
                                    object_controller_element,
                                    "CatalogReference",
                                )
                            )
                        )
            ed.add_entity_distribution_entry(weight, entityobject, controller)
        return ed

    def get_element(self) -> ET.Element:
        """Returns the ElementTree of the EntityDistribution.

        Returns
        -------
        ET.Element
            The ElementTree representation of the EntityDistribution.
        """

        if not self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                "EntityDistribution was introduced in OpenSCENARIO V1.3"
            )

        if not self.entity_distribution_entries:
            raise ValueError(
                "EntityDistribution must contain at least one EntityDistributionEntry"
            )

        element = ET.Element("EntityDistribution")
        for entry in self.entity_distribution_entries:
            # Unpack tuple: (weight, entityobject, controller)
            # weight, entityobject, controller = entry
            entry_el = ET.Element(
                "EntityDistributionEntry", attrib={"weight": str(entry.weight)}
            )
            scenario_object_template_element = ET.SubElement(
                entry_el, "ScenarioObjectTemplate"
            )
            scenario_object_template_element.append(
                entry.entityobject.get_element()
            )
            if entry.controller:
                # Support both single and multiple controllers
                controllers = (
                    entry.controller
                    if isinstance(entry.controller, list)
                    else [entry.controller]
                )
                for cnt in controllers:
                    objcont = ET.SubElement(
                        scenario_object_template_element, "ObjectController"
                    )
                    objcont.append(cnt.get_element())
            element.append(entry_el)
        return element


class TrafficDistribution(VersionBase):
    """The TrafficDistribution class creates the traffic distribution

    Attributes
    ----------
    traffic_distribution_entries :
        List of TrafficDistributionEntry objects.

    Methods
    -------
    add_traffic_distribution_entry(weight, entity_distribution, properties=None)
        Adds a TrafficDistributionEntry to the TrafficDistribution.
    parse(element)
        Parses an ElementTree created by the class and returns
        an instance of the class.
    get_element()
        Returns the full ElementTree of the class."""

    def __init__(self) -> None:
        self.traffic_distribution_entries = []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TrafficDistribution)
            and self.traffic_distribution_entries
            == other.traffic_distribution_entries
        )

    def add_traffic_distribution_entry(
        self,
        weight: float,
        entity_distribution: EntityDistribution,
        properties: Optional[Properties] = None,
    ) -> None:
        self.weight = convert_float(weight)
        if self.weight < 0:
            raise ValueError("Weight must be a non-negative value")

        if not isinstance(entity_distribution, EntityDistribution):
            raise TypeError(
                "entity_distribution must be of type EntityDistribution"
            )
        if properties is not None and not isinstance(properties, Properties):
            raise TypeError("properties must be of type Properties or None")

        self.traffic_distribution_entries.append(
            (weight, entity_distribution, properties)
        )

    @staticmethod
    def parse(element: ET.Element) -> "TrafficDistribution":
        """Parses the XML element of TrafficDistribution.

        Parameters
        ----------
        element : ET.Element
            A TrafficDistribution element.

        Returns
        -------
        TrafficDistribution
            A TrafficDistribution object.
        """
        td = TrafficDistribution()
        for entry_el in element.findall("TrafficDistributionEntry"):
            weight = float(entry_el.attrib["weight"])
            entity_dist_el = find_mandatory_field(
                entry_el, "EntityDistribution"
            )
            entity_distribution = EntityDistribution.parse(entity_dist_el)
            properties = None
            properties_el = entry_el.find("Properties")
            if properties_el is not None:
                properties = Properties.parse(properties_el)
            td.add_traffic_distribution_entry(
                weight, entity_distribution, properties
            )
        return td

    def get_element(self) -> ET.Element:
        """Returns the ElementTree of the TrafficDistribution."""

        if not self.isVersionEqLarger(minor=3):
            raise OpenSCENARIOVersionError(
                "TrafficDistribution was introduced in OpenSCENARIO V1.3"
            )
        if not self.traffic_distribution_entries:
            raise ValueError(
                "TrafficDistribution must contain at least one TrafficDistributionEntry"
            )

        element = ET.Element("TrafficDistribution")
        for (
            weight,
            entity_distribution,
            properties,
        ) in self.traffic_distribution_entries:
            entry_el = ET.Element(
                "TrafficDistributionEntry", attrib={"weight": str(weight)}
            )
            entry_el.append(entity_distribution.get_element())
            if properties is not None:
                entry_el.append(properties.get_element())
            element.append(entry_el)
        return element
