"""
  scenariogeneration
  https://github.com/pyoscx/scenariogeneration

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  Copyright (c) 2022 The scenariogeneration Authors.

"""

import xml.etree.ElementTree as ET


from .actions import _Action, _ActionType, _PrivateActionType, CustomCommandAction

from .triggers import EmptyTrigger, ValueTrigger, SimulationTimeCondition, Trigger
from .utils import (
    CatalogReference,
    EntityRef,
    _TriggerType,
    _EntityTriggerType,
    _ValueTriggerType,
    _BaseCatalog,
)
from .utils import (
    ParameterDeclarations,
    CatalogFile,
    convert_bool,
    convert_int,
    get_bool_string,
    convert_enum,
)
from .enumerations import Priority, Rule, ConditionEdge, VersionBase
from .actions import _GlobalActionFactory, _PrivateActionFactory


class Init(VersionBase):
    """the Init class, creates the init part of the storyboard

    Attributes
    ----------
        initactions (dir: {entityname: Action}): a directory
            containing all init actions of the scenario

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        get_element()
            Returns the full ElementTree of the class

        add_init_action(entityname, action):
            adds a private action to the init

        add_global_action(action):
            adds a global action to the init

        add_user_defined_action(action):
            adds a user defined action to the init

    """

    def __init__(self):
        """initalize the Init class"""
        self.initactions = {}
        self.global_actions = []
        self.user_defined_actions = []

    def __eq__(self, other):
        return isinstance(other, Init) and (
            self.initactions == other.initactions
            and self.global_actions == other.global_actions
            and self.user_defined_actions == other.user_defined_actions
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of Init
        NOTE: no UserDefinedActions are parsed.

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Init element (same as generated by the class itself)

        Returns
        -------
            init (Init): a Init object

        """
        init = Init()
        action_element = element.find("Actions")
        global_elements = action_element.findall("GlobalAction")
        for ga in global_elements:
            globalaction = _GlobalActionFactory.parse_globalaction(ga)
            init.add_global_action(globalaction)

        private_elements = action_element.findall("Private")
        for pe in private_elements:
            actor = pe.attrib["entityRef"]
            all_private_actions = pe.findall("PrivateAction")
            for pa in all_private_actions:
                privateaction = _PrivateActionFactory.parse_privateaction(pa)
                init.add_init_action(actor, privateaction)

        return init

    def add_init_action(self, entityname, action):
        """add_init_action adds an Private Action to the init.

        Parameters
        ----------
            entityname (str): name of the entity to add the action to
            action (*Action): Any private action to be added (like TeleportAction)

        """
        if not isinstance(action, _PrivateActionType):
            if isinstance(action, _ActionType):
                raise TypeError(
                    "the action provided is a global action, please use add_global_action instead"
                )
            raise TypeError("action input is not a valid action")
        if entityname not in self.initactions:
            self.initactions[entityname] = []

        self.initactions[entityname].append(action)

    def add_global_action(self, action):
        """add_global_action adds a global action to the init

        Parameters
        ----------
            action (*Action): any global action to add to the init

        """
        if isinstance(action, _PrivateActionType):
            raise TypeError(
                "action input is a Private action, please use add_init_action instead"
            )
        if not isinstance(action, _ActionType):
            raise TypeError("action input is not a valid action")
        self.global_actions.append(action)
        return self

    def add_user_defined_action(self, action):
        """add_user_defined_action adds a userDefined action to the init

        Parameters
        ----------
            action (CustomCommandAction): a custom command action (NOTE: a very crude implementation see actions.py)

        """
        if not isinstance(action, CustomCommandAction):
            raise TypeError("action is not of type CustomCommandAction")
        self.user_defined_actions.append(action)
        return self

    def get_element(self):
        """returns the elementTree of the Init"""
        element = ET.Element("Init")
        actions = ET.SubElement(element, "Actions")

        # add global actions
        for i in self.global_actions:
            actions.append(i.get_element())

        # add user defined actions
        for i in self.user_defined_actions:
            actions.append(i.get_element())

        # add private actions
        for i in self.initactions:
            private = ET.SubElement(actions, "Private", attrib={"entityRef": i})
            for j in self.initactions[i]:
                private.append(j.get_element())

        return element


class StoryBoard(VersionBase):
    """The StoryBoard class creates the storyboard of OpenScenario

    Parameters
    ----------
        init (Init): the init part of the storyboard

        stoptrigger (Valuetrigger, Entitytrigger or EmptyTrigger):
            the stoptrigger of the storyboard (optional)
            Default (EmptyTrigger)

    Attributes
    ----------
        init (Init): the init of the storyboard

        stoptrigger (Valuetrigger, Entitytrigger or EmptyTrigger):
            the stoptrigger

        stories (list of Story): all stories of the scenario

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_story (story)
            adds a story to the storyboard

        get_element()
            Returns the full ElementTree of the class


    """

    def __init__(self, init=Init(), stoptrigger=EmptyTrigger("stop")):
        """initalizes the storyboard

        Parameters
        ----------
            init (Init): the init part of the storyboard
                Default: Init()

            stoptrigger (Valuetrigger, Entitytrigger, Trigger, ConditionGroup or EmptyTrigger):
                the stoptrigger of the storyboard (optional)
                Default: (EmptyTrigger)

        """
        if not isinstance(init, Init):
            raise TypeError("init is not of type Init")
        if not isinstance(stoptrigger, _TriggerType):
            raise TypeError("stoptrigger is not a valid Trigger")
        # check that the stoptrigger has a triggeringpoint that is 'stop'
        if stoptrigger._triggerpoint == "StartTrigger":
            raise ValueError(
                "the stoptrigger provided does not have stop as the triggeringpoint"
            )
        self.init = init
        self.stoptrigger = stoptrigger
        self.stories = []

    def __eq__(self, other):
        return isinstance(other, StoryBoard) and (
            self.init == other.init
            and self.stoptrigger == other.stoptrigger
            and self.stories == other.stories
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of StoryBoard

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A StoryBoard element (same as generated by the class itself)

        Returns
        -------
            storyboard (StoryBoard): a StoryBoard object

        """
        init = Init.parse(element.find("Init"))
        stoptrigger = Trigger.parse(element.find("StopTrigger"))

        storyboard = StoryBoard(init, stoptrigger)
        for s in element.findall("Story"):
            storyboard.add_story(Story.parse(s))
        return storyboard

    def add_story(self, story):
        """adds a story to the storyboard

        Parameters
        ----------
            story (Story): the story to be added

        """
        if not isinstance(story, Story):
            raise TypeError("story input is not of type Story")
        self.stories.append(story)
        return self

    def add_act(self, act, parameters=ParameterDeclarations()):
        """add_act is a quick way to add a single act to one story, for multi act type of scenarios, use Story instead.

        NOTE: if used multiple times multiple stories will be created

        Parameters
        ----------
            act (Act): the Act to add

            parameters (ParameterDeclarations): the parameters of the story (optional)
                Default: ParameterDeclarations()
        """
        if not isinstance(act, Act):
            raise TypeError("act input is not of type Act")
        newstory = Story(f"story_{act.name}", parameters)
        newstory.add_act(act)
        self.stories.append(newstory)
        return self

    def add_maneuver_group(
        self,
        maneuvergroup,
        starttrigger=None,
        stoptrigger=EmptyTrigger("stop"),
        parameters=ParameterDeclarations(),
    ):
        """add_maneuver_group is a quick way to add a single maneuver_group to one story, for multi maneuver_group type of scenarios, use Act instead.

        NOTE: if used multiple times multiple stories will be created

        Parameters
        ----------
            maneuvergroup (ManeuverGroup): the ManeuverGroup to add

            starttrigger (Valuetrigger, Entitytrigger, Trigger, ConditionGroup or EmptyTrigger): starttrigger for the act
                Default: at simulationtime 0

            stoptrigger (Valuetrigger, Entitytrigger, Trigger, ConditionGroup or EmptyTrigger): stoptrigger for the act
                Default: EmptyTrigger('stop')

            parameters (ParameterDeclarations): the parameters of the story (optional)
                Default: ParameterDeclarations()

        """
        if not isinstance(maneuvergroup, ManeuverGroup):
            raise TypeError("maneuvergroup input is not of type ManeuverGroup")
        if starttrigger is None:
            starttrigger = ValueTrigger(
                "act_start",
                0,
                ConditionEdge.rising,
                SimulationTimeCondition(0, Rule.greaterThan),
            )
        elif not isinstance(starttrigger, _TriggerType):
            raise TypeError("starttrigger is not a Trigger type")
        elif starttrigger._triggerpoint == "StopTrigger":
            raise ValueError(
                "the starttrigger provided does not have start as the triggeringpoint"
            )
        if not isinstance(stoptrigger, _TriggerType):
            raise TypeError("stoptrigger is not a Trigger type")
        if stoptrigger._triggerpoint == "StartTrigger":
            raise ValueError("the stoptrigger provided is not of type StopTrigger")
        newact = Act(f"act_{maneuvergroup.name}", starttrigger, stoptrigger)
        newact.add_maneuver_group(maneuvergroup)
        self.add_act(newact, parameters)
        return self

    def add_maneuver(
        self,
        maneuver,
        actors=None,
        starttrigger=None,
        stoptrigger=EmptyTrigger("stop"),
        parameters=ParameterDeclarations(),
    ):
        """add_maneuver is a quick way to add a single maneuver to one story, for multi maneuver type of scenarios, use ManeuverGroup instead.

        NOTE: if used multiple times multiple stories will be created

        Parameters
        ----------
            maneuver (Maneuver or CatalogReference): the Maneuver to add

            actors (list of 'str', or 'str'): list of all actors in the maneuver or just a name of the actor

            starttrigger (Valuetrigger, Entitytrigger, Trigger, ConditionGroup or EmptyTrigger): starttrigger for the act
                Default: at simulationtime 0

            stoptrigger (Valuetrigger, Entitytrigger, Trigger, ConditionGroup or EmptyTrigger): stoptrigger for the act
                Default: EmptyTrigger('stop')

            parameters (ParameterDeclarations): the parameters of the story (optional)
                Default: None

        """
        if not (isinstance(maneuver, (Maneuver, CatalogReference))):
            raise TypeError("maneuver input is not of type Maneuver")
        if isinstance(maneuver, Maneuver):
            mangr = ManeuverGroup(f"maneuvuergroup_{maneuver.name}")
        else:
            mangr = ManeuverGroup("maneuvuergroup_from_catalog")

        if actors is not None:
            if isinstance(actors, list):
                for a in actors:
                    mangr.add_actor(a)
            else:
                mangr.add_actor(actors)
        mangr.add_maneuver(maneuver)
        self.add_maneuver_group(
            mangr,
            starttrigger=starttrigger,
            stoptrigger=stoptrigger,
            parameters=parameters,
        )
        return self

    def get_element(self):
        """returns the elementTree of the Storyboard"""
        element = ET.Element("Storyboard")
        element.append(self.init.get_element())

        # if not self.stories:
        #     raise ValueError('no stories available for storyboard')

        if not self.stories:
            self.add_maneuver_group(ManeuverGroup("empty"), EmptyTrigger())
        for story in self.stories:
            element.append(story.get_element())

        element.append(self.stoptrigger.get_element())

        return element


class Story(VersionBase):
    """The Story class creates a story of the OpenScenario

    Parameters
    ----------
        name (str): name of the story

        parameters (ParameterDeclarations): the parameters of the Story
            Default: ParameterDeclarations()

    Attributes
    ----------
        name (str): name of the story

        parameters (ParameterDeclarations): the parameters of the story (optional)

        acts (list of Act): all acts belonging to the story

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_act(act)
            adds an act to the story

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    """

    def __init__(self, name, parameters=ParameterDeclarations()):
        """initalizes the Story class

        Parameters
        ----------
            name (str): name of the story

            parameters (ParameterDeclarations): the parameters of the Story
        """
        self.name = name

        self.acts = []
        if not isinstance(parameters, ParameterDeclarations):
            raise TypeError("parameters input is not of type ParameterDeclarations")

        self.parameter = parameters

    def __eq__(self, other):
        return isinstance(other, Story) and (
            self.get_attributes() == other.get_attributes()
            and self.parameter == other.parameter
            and self.acts == other.acts
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of Story

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Story element (same as generated by the class itself)

        Returns
        -------
            story (Story): a Story object

        """
        name = element.attrib["name"]
        if element.find("ParameterDeclarations") is None:
            parameters = ParameterDeclarations()
        else:
            parameters = ParameterDeclarations.parse(
                element.find("ParameterDeclarations")
            )
        story = Story(name, parameters)
        for a in element.findall("Act"):
            story.add_act(Act.parse(a))
        return story

    def add_act(self, act):
        """adds an act to the story

        Parameters
        ----------
            act (Act): act to add to the story

        """
        if not isinstance(act, Act):
            raise TypeError("act input is not of type Act")
        self.acts.append(act)
        return self

    def get_attributes(self):
        """returns the attributes as a dict of the Story"""
        return {"name": self.name}

    def get_element(self):
        """returns the elementTree of the Story"""
        element = ET.Element("Story", attrib=self.get_attributes())
        if self.parameter.get_element():
            element.append(self.parameter.get_element())
        if not self.acts:
            raise ValueError("no acts added to the story")
        for a in self.acts:
            element.append(a.get_element())
        return element


class Act(VersionBase):
    """the Act class creates the Act of the OpenScenario

    Parameters
    ----------
        name (str): name of the act

        starttrigger (*Trigger): starttrigger of the act
            Default: ValueTrigger('act_start',0,ConditionEdge.none,SimulationTimeCondition(0,Rule.greaterThan))

        stoptrigger (*Trigger): stoptrigger of the act (optional)

    Attributes
    ----------
        name (str): name of the act

        starttrigger (*Trigger): starttrigger of the act

        stoptrigger (*Trigger): stoptrigger of the act (optional)

        maneuvergroup (list of ManeuverGroup): list of ManeuverGroups belonging to the act

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_maneuver_group(maneuvergroup)
            adds a maneuvuergroup to the act

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    """

    def __init__(self, name, starttrigger=None, stoptrigger=None):
        """Initalize the Act

        Parameters
        ----------
            name (str): name of the act

            starttrigger (*Trigger): starttrigger of the act
                Default: ValueTrigger('act_start',0,ConditionEdge.none,SimulationTimeCondition(0,Rule.greaterThan))

            stoptrigger (*Trigger): stoptrigger of the act (optional)
                Default: Emptytrigger

        """

        self.name = name
        if starttrigger is None:
            self.starttrigger = starttrigger = ValueTrigger(
                "act_start",
                0,
                ConditionEdge.none,
                SimulationTimeCondition(0, Rule.greaterThan),
            )
        elif not isinstance(starttrigger, _TriggerType):
            raise TypeError("starttrigger is not a valid TriggerType")
        elif starttrigger._triggerpoint == "StopTrigger":
            raise ValueError(
                "the starttrigger provided does not have start as the triggeringpoint"
            )
        else:
            self.starttrigger = starttrigger

        if stoptrigger is None:
            self.stoptrigger = EmptyTrigger("stop")
        elif not isinstance(stoptrigger, _TriggerType):
            raise TypeError("stoptrigger is not a valid TriggerType")
        elif stoptrigger._triggerpoint == "StartTrigger":
            raise ValueError("the stoptrigger provided is not of type StopTrigger")
        else:
            self.stoptrigger = stoptrigger

        self.maneuvergroup = []

    def __eq__(self, other):
        return isinstance(other, Act) and (
            self.starttrigger == other.starttrigger
            and self.stoptrigger == other.stoptrigger
            and self.maneuvergroup == other.maneuvergroup
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of Act

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Act element (same as generated by the class itself)

        Returns
        -------
            act (Act): a Act object

        """
        name = element.attrib["name"]
        stoptrigger = None
        if element.find("StopTrigger") is not None:
            stoptrigger = Trigger.parse(element.find("StopTrigger"))
        starttrigger = Trigger.parse(element.find("StartTrigger"))

        act = Act(name, starttrigger, stoptrigger)
        for m in element.findall("ManeuverGroup"):
            act.add_maneuver_group(ManeuverGroup.parse(m))
        return act

    def add_maneuver_group(self, maneuvergroup):
        """adds a maneuvuergroup to the act

        Parameters
        ----------
            maneuvergroup (ManeuverGroup): the maneuvergroup to add

        """
        if not isinstance(maneuvergroup, ManeuverGroup):
            raise TypeError("maneuvergroup is not of type ManeuverGroup")
        self.maneuvergroup.append(maneuvergroup)
        return self

    def get_attributes(self):
        """returns the attributes as a dict of the Act"""
        return {"name": self.name}

    def get_element(self):
        """returns the elementTree of the Act"""
        element = ET.Element("Act", attrib=self.get_attributes())
        if not self.maneuvergroup:
            raise ValueError("no maneuver group added to the act")
        for mangr in self.maneuvergroup:
            element.append(mangr.get_element())

        element.append(self.starttrigger.get_element())
        element.append(self.stoptrigger.get_element())
        return element


class ManeuverGroup(VersionBase):
    """the ManeuverGroup creates the ManeuverGroup of the OpenScenario

    Parameters
    ----------
        name (str): name of the ManeuverGroup

        maxexecution (int): maximum number of iterations

        selecttriggeringentities (bool): Have no idea what this does ??? TODO: check

    Attributes
    ----------
        name (str): name of the ManeuverGroup

        maxexecution (int): maximum number of iterations

        selecttriggeringentities (bool): Have no idea what this does ??? TODO: check

        maneuvers (list of Maneuver): the maneuvers in the ManeuverGroup

        actors (_Actors): all actors of the ManeuverGroup

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_maneuver(Maneuver)
            adds a maneuver to the ManeuverGroup

        add_actor(entity)
            adds an actor to the ManeuverGroup

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    """

    def __init__(self, name, maxexecution=1, selecttriggeringentities=False):
        """initalize the ManeuverGroup

        Parameters
        ----------
            name (str): name of the ManeuverGroup

            maxexecution (int): maximum number of iterations

            selecttriggeringentities (bool): Have no idea what this does ??? TODO: check

        """
        self.name = name
        self.maxexecution = convert_int(maxexecution)
        self.actors = _Actors(selecttriggeringentities)
        self.maneuvers = []

    def __eq__(self, other):
        return isinstance(other, ManeuverGroup) and (
            self.get_attributes() == other.get_attributes()
            and self.actors == other.actors
            and self.maneuvers == other.maneuvers
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of ManeuverGroup

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A ManeuverGroup element (same as generated by the class itself)

        Returns
        -------
            maneuver_group (ManeuverGroup): a ManeuverGroup object

        """

        name = element.attrib["name"]
        maxexec = convert_int(element.attrib["maximumExecutionCount"])
        actors = _Actors.parse(element.find("Actors"))
        maneuver_group = ManeuverGroup(name, maxexec)
        maneuver_group.actors = actors
        for m in element.findall("Maneuver"):
            maneuver_group.add_maneuver(Maneuver.parse(m))
        for cr in element.findall("CatalogReference"):
            maneuver_group.add_maneuver(CatalogReference.parse(cr))

        return maneuver_group

    def add_maneuver(self, maneuver):
        """adds a maneuver to the ManeuverGroup

        Parameters
        ----------
            maneuver (Maneuver, or CatalogReference): maneuver to add

        """
        if not (isinstance(maneuver, (Maneuver, CatalogReference))):
            raise TypeError("maneuver input is not of type Maneuver")
        self.maneuvers.append(maneuver)
        return self

    def add_actor(self, entity):
        """adds an actor to the ManeuverGroup

        Parameters
        ----------
            entity (str): name of the entity to add as an actor

        """
        self.actors.add_actor(entity)
        return self

    def get_attributes(self):
        """returns the attributes as a dict of the ManeuverGroup"""
        return {"name": self.name, "maximumExecutionCount": str(self.maxexecution)}

    def get_element(self):
        """returns the elementTree of the ManeuverGroup"""
        element = ET.Element("ManeuverGroup", attrib=self.get_attributes())
        element.append(self.actors.get_element())
        for man in self.maneuvers:
            element.append(man.get_element())
        return element


class _Actors(VersionBase):
    """_Actors is used to create the actors of a ManeuverGroup

    Parameters
    ----------
        selectTriggeringEntities (bool): ???
            Default: False

    Attributes
    ----------
        selectTriggeringEntities (bool): ???

        actors (list or EntityRef): all actors to add to the element

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_actor(actor)
            adds an actor

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    """

    def __init__(self, selectTriggeringEntities=False):
        """initalize the _Actors

        Parameters
        ----------
            selectTriggeringEntities (bool): ???
                Default: False

        """
        self.actors = []
        self.select = convert_bool(selectTriggeringEntities)

    def __eq__(self, other):
        return isinstance(other, _Actors) and (
            self.get_attributes() == other.get_attributes()
            and self.actors == other.actors
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of _Actors

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A _Actors element (same as generated by the class itself)

        Returns
        -------
            actors (_Actors): a _Actors object

        """
        trigent = convert_bool(element.attrib["selectTriggeringEntities"])
        actors = _Actors(trigent)
        entrefs = element.findall("EntityRef")
        for ent in entrefs:
            entityref = EntityRef.parse(ent)
            actors.add_actor(entityref.entity)
        return actors

    def add_actor(self, entity):
        """adds an actor to the list of actors

        Parameters
        ----------
            entity (str): name of the entity

        """
        self.actors.append(EntityRef(entity))
        return self

    def get_attributes(self):
        """returns the attributes of the _Actors as a dict"""
        return {"selectTriggeringEntities": get_bool_string(self.select)}

    def get_element(self):
        """returns the elementTree of the _Actors"""
        # if not self.actors:
        #     raise ValueError('no actors are set')
        if len(self.actors) == 0:
            Warning("No Actors are defined")
        element = ET.Element("Actors", attrib=self.get_attributes())
        for ent in self.actors:
            element.append(ent.get_element())
        return element


class Maneuver(_BaseCatalog):
    """The Maneuver class creates the Maneuver of OpenScenario

    Parameters
    ----------
        name (str): name of the Maneuver

        parameters (ParameterDeclaration): Parameter declarations for the maneuver
            Default: None

    Attributes
    ----------
        name (str): name of the Maneuver

        events (list of Event): all events belonging to the Maneuver

        parameters (ParameterDeclaration): Parameter declarations for the maneuver

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_event (event)
            adds an event to the Maneuver

        append_to_catalog(filename)
            adds the vehicle to an existing catalog

        dump_to_catalog(filename,name,description,author)
            crates a new catalog with the vehicle

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    """

    def __init__(self, name, parameters=None):
        """initalizes the Maneuver
        Parameters
        ----------
            name (str): name of the Maneuver

        """
        super().__init__()
        if parameters is not None and not isinstance(parameters, ParameterDeclarations):
            raise TypeError("parameters is not of type ParameterDeclarations")
        if parameters is not None:
            self.parameters = parameters
        self.name = name
        self.events = []

    def __eq__(self, other):
        return isinstance(other, Maneuver) and (
            self.get_attributes() == other.get_attributes()
            and self.parameters == other.parameters
            and self.events == other.events
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of Maneuver

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Maneuver element (same as generated by the class itself)

        Returns
        -------
            maneuver (Maneuver): a Maneuver object

        """
        parameters = None
        if element.find("ParameterDeclarations") is not None:
            parameters = ParameterDeclarations.parse(
                element.find("ParameterDeclarations")
            )
        name = element.attrib["name"]
        man = Maneuver(name, parameters)

        for e in element.findall("Event"):
            man.add_event(Event.parse(e))
        return man

    def add_event(self, event):
        """adds an event to the Maneuver

        Parameters
        ----------
            name (Event): the event to add to the Maneuver

        """
        if not isinstance(event, Event):
            raise TypeError("event input is not of type Event")
        self.events.append(event)
        return self

    def get_attributes(self):
        """returns the attributes as a dict of the Maneuver"""
        return {"name": self.name}

    def get_element(self):
        """returns the elementTree of the Maneuver"""
        if not self.events:
            raise ValueError("no events added to the maneuver")

        element = ET.Element("Maneuver", attrib=self.get_attributes())
        self.add_parameters_to_element(element)
        for event in self.events:
            element.append(event.get_element())

        return element


class Event(VersionBase):
    """the Event class creates the event of OpenScenario

    Parameters
    ----------
        name (str): name of the event

        priority (Priority): what priority the event has

        maxexecution (int): the maximum allowed executions of the event
            Default: 1

    Attributes
    ----------
        name (str): name of the event

        priority (Priority): what priority the event has TODO: add definition

        maxexecution (int): the maximum allowed executions of the event

        action (list of actions): all actions belonging to the event

        trigger (*Trigger): a start trigger to the event

    Methods
    -------
        parse(element)
            parses a ElementTree created by the class and returns an instance of the class

        add_trigger()
            adds an trigger to the event

        add_action()
            adds an action to the event (can be called multiple times)

        get_element()
            Returns the full ElementTree of the class

        get_attributes()
            Returns a dictionary of all attributes of the class

    """

    def __init__(self, name, priority, maxexecution=1):
        self.name = name
        self.priority = convert_enum(priority, Priority)
        self.action = []
        self.trigger = None
        self.maxexecution = convert_int(maxexecution)

    def __eq__(self, other):
        return isinstance(other, Event) and (
            self.get_attributes() == other.get_attributes()
            and self.trigger == other.trigger
            and self.action == other.action
        )

    @staticmethod
    def parse(element):
        """Parses the xml element of Event

        Parameters
        ----------
            element (xml.etree.ElementTree.Element): A Event element (same as generated by the class itself)

        Returns
        -------
            event (Event): a Event object

        """
        name = element.attrib["name"]
        maxexec = None
        if "maximumExecutionCount" in element.attrib:
            maxexec = convert_int(element.attrib["maximumExecutionCount"])
        prio = getattr(Priority, element.attrib["priority"])

        event = Event(name, prio, maxexec)

        event.add_trigger(Trigger.parse(element.find("StartTrigger")))

        all_actions = []
        for a in element.findall("Action"):
            event.action.append(_Action.parse(a))

        return event

    def add_trigger(self, trigger):
        """adds a starging trigger to the event

        Parameters
        ----------
            trigger (*Trigger): Adds a trigger to start the event (not EmptyTrigger)

        """
        if not isinstance(trigger, _TriggerType):
            if isinstance(trigger, _ValueTriggerType):
                raise TypeError(
                    "trigger input is a value trigger condition, please add it to a ValueTrigger."
                )
            elif isinstance(trigger, _EntityTriggerType):
                raise TypeError(
                    "trigger input is an entity trigger condition, please add it to an EntityTrigger."
                )
            raise TypeError("trigger input is not a valid trigger")
        self.trigger = trigger
        return self

    def add_action(self, actionname, action):
        """adds an action to the Event, multiple actions can be added and will be ordered as added.

        Parameters
        ----------
            action (*Action): any action to be added to the event

        """
        if not isinstance(action, _ActionType):
            raise TypeError("action input is not a valid Action")
        self.action.append(_Action(actionname, action))
        return self

    def get_attributes(self):
        """returns the attributes as a dict of the Event"""
        retdict = {"name": self.name, "priority": self.priority.get_name()}
        if self.maxexecution is not None:
            retdict["maximumExecutionCount"] = str(self.maxexecution)
        return retdict

    def get_element(self):
        """returns the elementTree of the Event"""
        if not self.action:
            raise ValueError("no action(s) set")
        if self.isVersion(minor=0) and not self.trigger:
            raise ValueError("no trigger set")

        element = ET.Element("Event", attrib=self.get_attributes())
        for action in self.action:
            element.append(action.get_element())
        if self.trigger:
            element.append(self.trigger.get_element())
        return element
